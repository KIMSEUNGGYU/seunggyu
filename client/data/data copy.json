{
  "posts": [
    {
      "title": "자료구조 - 스택",
      "date": "2021.04.07",
      "description": "test description",
      "tags": ["자료구조"],
      "content": "# 스택\n\n- 가장 나중에 삽입한 데이터를 가장 먼저 빼내는 데이터 구조\n- LIFO (Last In First Out)\n\n## 기능\n\n- `push`\n\n    데이터를 스택에 넣기\n\n- `pop`\n\n    데이터를 스택에서 꺼내기\n\n## 스택의 장단점\n\n### 장점\n\n- 구조가 단순하고 구현이 쉬움\n- 데이터 저장/읽기 속도가 빠름\n\n### 단점\n\n- 데이터 최대 갯수를 미리 정해야함\n    - 파이썬의 경우 재귀 함수는 최대 1000번 까지만 가능\n- 저장 공간의 낭비가 발생할 수 있음.\n    - 미리 최대 갯수 만큼 저장 공간을 확보해야함\n\n→ 스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임. 이 경우, 위에서 열거한 단점이 있을 수 있음\n\n## 리스트로 스택 구현하기\n\n- 리스트로 스택 구현하기\n\n    ```python\n    stack_list = list()\n\n    def push(data):\n        \"\"\" 데이터 삽입 \"\"\"\n        stack_list.append(data)\n        \n    def pop():\n        \"\"\" 데이터 삭제 \"\"\"\n        if len(stack_list) <= 0:\n            return -1   ## 에러 처리\n        data = stack_list[-1]\n        del stack_list[-1]\n        return data\n        \n    ## 실행\n    for i in range(10):\n        push(i)\n\n    print(pop())\n    print(pop())\n    ```\n\n- 사실상 파이썬에서 제공하는 `append()` 와 `pop()` 을 사용하면 스택 처럼 활용 가능\n\n## 스택 활용\n\n- 컴퓨터 내부의 프로세스 구조의 **함수 동작 방식**\n\n    프로세스에서 함수를 처리하는 동작 방식에서 스택이라는 자료 구조 사용\n\n    - 재귀함수를 이용한 간단한 예제",
      "id": 1
    },
    {
      "title": "자료구조 - 큐",
      "date": "2021.04.07",
      "description": "test description",
      "tags": ["자료구조"],
      "content": "# 큐\n\n- 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 자료 구조\n- FIFO(First In First Out ) , LILO(Last In Last Out) 방식으로 스택과 꺼내는 순서가 반대\n\n## 용어\n\n- `Enqueue`\n\n    큐에 데이터를 넣는 기능\n\n- `Dequque`\n\n    큐에 데이터를 꺼내는 기능\n\n## 파이썬 라이브러리\n\n1. `Queue`\n\n    일반 적인 큐 자료 구조\n\n2. `LifoQueue`\n\n    나중에 입력된 데이터가 먼저 출력되는 구조 → 스택 \n\n3. `PriorityQueue`\n\n    데이터마다 우선순위를 넣어, 우선순위가 높은 순으로 데이터 출력\n\n## 큐 연산\n\n- `qsize`\n\n    큐 안에 있는 원소의 수?\n\n- `put`\n\n    큐 안에 있는 **데이터 삽입**\n\n- `get`\n\n    큐 안에 있는 **데이터 가져오기**\n\n1. Queue 예제\n    - Queue 예제\n2. LIFO QUEUE\n    - LIFO QUEUE 예제\n    - 스택 구조\n3. Priority Queue\n    - Priority Queue 예제\n\n- 우선순위 큐인 경우 튜플형식으로 우선순위, 데이터 를 넣어야함\n- 우선순위가 높은 것이 숫자가 낮음\n\n## 큐 규현해보기\n\n- 리스트를 이용하여 간단한 큐 구현하기\n\n```python\nqueue_list = list()\n\ndef enqueue(data):\n    \"\"\"데이터를 삽입하는 기능\"\"\"\n    queue_list.append(data)\n    \ndef dequeue():\n    \"\"\"데이터를 가져오는 기능\"\"\"\n    if len(queue_list) <= 0:\n        return -1\n    data = queue_list[0]\n    del queue_list[0]\n    return data\n\n## 수행 \nfor index in range(2):\n    enqueue(index)\n\nprint(dequeue())  # 0\nprint(dequeue())  # 1\n# print(dequeue())  # -1 ## 에러 처리\n```\n\n## 큐는 어디에서 많이 쓰일까??\n\n- 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨\n\n### 멀티 태스킹이란?\n\n- 한개의 CPU 를 가진 컴퓨터는 원치적으로 하나의 하나의 작업을 수행한다.\n\n    하지만 컴퓨터의 연산 속도는 인간의 작업 처리 속도보다 빠르기 때문에 스케줄링이라는 방식을 사용해 컴퓨터 사용자에게 병렬 연산이 이루어지는 것과 같은 환경을 제공하는 것!\n\n- 사람의 처리 속도는 초 단위로 판단하지만, 컴퓨터는 그 보다 훨씬 빠르게 작업하기 때문에 하나의 작업을 수행하지만, 사용자가 인식하지 못하는 선에서 작업을 쪼개서 빠르게 여러 작업을 수행해 멀티 작업을 하는 것처럼 인식하게 하는 방법",
      "id": 2
    },
    {
      "title": "자료구조 - 링크드리스트",
      "date": "2021.04.07",
      "description": "test description",
      "tags": ["자료구조"],
      "content": "# 링크드 리스트\n\n- `**배열**`은 **순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조**\n- `**링크드 리스트**` 는 **떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조**\n\n## 용어\n\n- `**노드(node)**`\n\n    데이터 저장 단위,  ( 데이터 값, 포인터) 로 구성\n\n- **`포인터 (pointer)`**\n\n    각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간\n\n## 링크드리스트 장/단점\n\n- **장점**\n    - 미리 데이터 공간을 할당하지 않아도 됨\n    배열은 미리 데이터 공간을 할당 해야함\n- 단점\n    - 연결을 위한 별도 데이터 공간이 필요해, 저장공간이 효율적 이지 않음.\n    - 연결 정보를 찾는 시간이 필요해 접근 속도가 느림\n\n        처음부터 차례대로 읽으면서 검색함\n\n    - 중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요\n\n        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8514901f-7d28-4d30-943a-3c45ac19cb06/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8514901f-7d28-4d30-943a-3c45ac19cb06/Untitled.png)\n\n## 링크드 리스트 구현\n\n```python\nclass Node:\n    \"\"\"링크드리스트 노드 클래스\"\"\"\n    def __init__(self, data, next=None):\n        self.data = data\n        self.next = next\n\nclass Linkedlist:\n    \"\"\"링크드리스트 관리하는 클래스\"\"\"\n    def __init__(self, data):\n        self.head = Node(data)\n    \n    def add(self, data):\n        \"\"\"링크드 리스트 맨 마지막에 노드 추가하는 기능\"\"\"\n        if self.head == \"\":\n            self.head = Node(data)\n        else:\n            node = self.head\n            while node.next:\n                node = node.next\n            node.next = Node(data)\n        \n    def description(self):\n        \"\"\"링크드리스트의 모든 데이터를 출력하는 기능\"\"\"\n        node = self.head\n        while node:\n            print(node.data)\n            node = node.next\n            \n    def delete(self, data):\n        \"\"\"링크드리스트 특정 노드 삭제\n        고려사항\n        1. head 를 삭제\n        2. 중간 노드를 삭제\n        3. 마지막 노드를 삭제\n        \"\"\"\n        if self.head == \"\":\n            print(\"해당 값을 가진 노드가 존재하지 않습니다.\")\n            return\n        \n        if self.head.data == data:    # 1. head 삭제\n            temp = self.head\n            self.head = self.head.next\n            del temp # 객체 삭제\n        else:\n            node = self.head\n            while node.next:\n                if node.next.data == data:\n                    temp = node.next\n                    node.next = node.next.next\n                    del temp\n                else:\n                    node = node.next\n    \n    def search_node(self, data):\n        \"\"\"링크드리스트 특정 노드 탐색\"\"\"\n        node = self.head\n\n        while node.next:\n            if node.data == data:\n                return node\n            else:\n                node = node.next\n        \n        return Node(-1)   # 특정 노드 찾기 못하면 \n```\n\n```python\n## 수행\nlinked_list1 = Linkedlist(0)\n\nfor data in range(1, 10):\n    linked_list1.add(data)\n\nlinked_list1.description()\n\nprint(\"\\n4의 데이터 삭제 - 중간 노드 삭제\")\nlinked_list1.delete(4)\nlinked_list1.description()\n\nprint(\"\\n9의 데이터 삭제 - 마지막 노드 삭제\")\nlinked_list1.delete(9)\nlinked_list1.description()\n\nprint(\"\\n노드 탐색 \")\nnode = linked_list1.search_node(4)\nprint('탐색 노드:', node.data)\n```\n\n## 더블 링크드 리스트  (이중 연결 리스트)\n![Untitled](http://res.cloudinary.com/du4w00gvm/image/upload/v1618659975/fwdxhdnl8t943rm3wtzm.png)\n\n- 양방향으로 연결되어 있어 노드 탐색이 양쪽으로 모두 가능\n양쪽에 있으면, 단일과 달리 탐색 데이터에 따라 앞(head) 뒤(tail) 에서 탐색할 수 있음\n\n    단일 링크드 리스트는 앞(head) 만 탐색 가능",
      "id": 3
    }
  ]
}
